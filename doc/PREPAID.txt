DESCRIPTION
-----------

Prepaid functionality is achieved by:

1. An external call control module (not provided by CDRTool) that maintains
call status and terminates calls by sending BYEs to both SIP end-points. The
call control module communicates with both the SIP Proxy and CDRTool using
an API described below. 

2. CDRTool rating engine - provides session locking, calculates maximum
session time based on user balance and destination using the same algorithm
as the postpaid engine and debits the subscriber balance.

See doc/PrepaidEngine.pdf for a detailed call flow.


Prepaid API
-----------

CDRTool prepaid engine is used to compute session times based on user credit
and destination rates and debit the balance when the call has ended. The
prepaid engine is accessible over the TCP socket where the rating engine
listens.

The TCP socket location is configured in /etc/default/cdrtool. The
connection can be tested manually using the telnet command and by typing
help at the prompt:

tstuser@host:~$ telnet 10.0.0.0.1 9024
Trying 10.0.0.1...
Connected to 10.0.0.1.
Escape character is '^]'.
Help
MaxSessionTime        From=sip:123@example.com To=sip:0031650222333@example.com Duration=7200 Gateway=10.0.0.1 Lock=1
AddBalance            From=123@example.com Value=10.00
GetBalance            From=123@example.com
GetBalanceHistory     From=123@example.com
DeleteBalance         From=123@example.com
DeleteBalanceHistory  From=123@example.com
DebitBalance          From=sip:123@example.com To=sip:0031650222333@example.com Gateway=10.0.0.1 Duration=59
ShowPrepaidAccounts   Filter=123@example.com
ReloadPrepaidAccounts Account=abc@example.com

In the example above only the commands related to the prepaid functionality
are highlighted.

Call control module sends commands based on the syntax described below, to
the CDRTool prepaid engine that handles the prepaid accounts. A command is a
line of text containing a keyword, which is the command itself followed by a
number of parameters separated by space. The command ends with an enter in
unix style: '\n' For each such request there will be a reply on one or more
lines, containing information that depends on the command that was sent. A
reply ends when a double end of line (\n) is received: \n\n (this is needed
because there are commands that require multiline responses). How the
information contained in a reply is to be interpreted depends on the command
itself and is described below.


1. Asking for the call time limit
   ------------------------------

To request the maximum time for a session, the following request must be
sent to CDRTool rating engine on one line:

MaxSessionTime From=sip:123@example.com To=sip:0031650222@example.com
Duration=7200 Gateway=81.20.68.10 ENUMtl=tld.com Lock=1\n

Duration is a limit imposed to the time allowed, in case you want to limit
the call time to a maximum duration. This will be a top limit for the call's
time, even if the user could talk more than that based on his current
balance. The SIP proxy may limit all calls to 7200 seconds for example. 
Lock specifies if the account is to be locked or not (i.e. don't allow the
same user make multiple calls at the same time). This is used because
sometimes we only need to peek at the time but not actually start a call and
lock the user. When the call starts the account should always be locked. To
may actually be sip:number@domain;param=value so you must extract the
username part which is the number From is a sip URI which can be "full name"

ENUMtld parameter is optional but if present discounts based on ENUM can be
applied (see RATING.txt for more information on ENUM discounts).

Call control expects a reply like below:

value\n\n

value is the numeric time in seconds, or one of the keywords Locked or None
(None meaning it's not a prepaid account and it doesn't have any limitation,
or it's a free destination, like a 0800... number).  There is no empty line
before value (response starts with value on the first line and then it has 2
enters unix style as described).

To field must be the canonical destination SIP URI after all possible
lookups in the SIP Proxy.

2. Debiting the balance when the conversation ends
   -----------------------------------------------

To debit money from the user account when the conversation ends, the Call
control module must send the following command on one line:

DebitBalance From=sip:123@example.com To=sip:0031650222@example.com
Gateway=81.20.68.10 Duration=59\n

Same notes about the From and To fields as above apply.

and expects in return:

value\n\n

where value is one of: OK (success), Failed (failure), Not Prepaid (account
is not prepaid - this case is not considered a failure)

There are cases where we call DebitBalance with a 0 duration. This is valid
and should unlock the account but leave the credit untouched.


Prepaid calls in progress
-------------------------

To see the calls in progress go to Rating -> Prepaid.

Fill in the Sesssions field: >0 and click Search.


Third party tools
-----------------

FreeRADIUS-CDRTool by Dan-Cristian Bogos 

FreeRADIUS module providing connectivity to CDRTool prepaid engine. Provides
prepaid authentication for calls proxied by OpenSER and returns to OpenSER
MaxCallDuration and user Credit. Can be easily extended to support other SIP
or H323 devices.

http://sourceforge.net/projects/frad-cdrtool


Notes
-----

The balance is debited correctly regardless of the moment of CDR
normalization. Renormalization of calls do not recalculate balance.


Simultaneous prepaid calls
--------------------------

Since version 6.6.0 is possible to have multiple calls using the same
prepaid account without the risk of reaching a negative balance.

The modus operandi is based on a simple model: all prepaid calls belonging
to the same account must end at the same moment regadless of the called
destinations and their different prices. The rating engine simply calculates
that moment based on the data available from ongoing calls, available
balance and the new call setup request. This scheme provides a fair
balancing policy with small performance penalty on the servers.

By using this simple model there is no need to poll any database during
ongoing calls, which could become major scalability problem. All the work is
done only once at call setup time. This will increase the load on the rating
engine only during call setup and only for the users that have parallel
sessions, the rating engine will perform internally during each call setup 2
x the number of sessions calls to ShowPrice and MaxSessionTime functions.

You must set $RatingEngine['prepaid_lock'] to 0 in etc/cdrtool/global.inc
and update the call control software module that keeps track of the maximum
session time to enforce call ending for all calls belonging to the same sip
account at the same time based on the last value of MaxSessionTime received
from the rating engine. The previous version required the call control
module to keep the time counter per sip session, now it needs to sync the
counter for all calls belonging to the same sip account. See below the
pseudo code for the call control engine.

The list of ongoing prepaid calls can be monitored in the Prepaid accounts
section of the Rating pages. For each sip account that has ongoing calls a
link marked Sessions apears in the left side of the prepaid record. Click on
it to display the ongoing prepaid sessions. The 'Delete session' button
allows the removal of the session form the rating engine. The expired
sessions that have not been closed properly by the call control module are
automatically purged 120 seconds after expiration, which has been chosen to
cover a reasonable call setup time.

The time and balance distribution between parallel calls is logged detailed
in the syslog:

cdrtool[13292]: MaxSessionTime From=sip:adi@umts.ro Lock=1 To=sip:00318008185@umts.ro CallId=waaivgq89aTxmPIG6JIsPhODUe0tRVf- Duration=36000 Gateway=80.101.96.20
cdrtool[13292]: ConnectFee=0.0450 Span=1 Duration=16 DestId=31646 default Profile=442 Period=weekend Rate=442 Interval=0-24 Cost=0.1600/60 Price=0.0427
cdrtool[13292]: Ongoing prepaid session uw1znivnqoeofyezzuiiisudukw64cm- for adi@umts.ro to sip:0031646999425@umts.ro: duration=16, price=0.0877 
cdrtool[13292]: Balance for adi@umts.ro having 1 ongoing sessions: database=9.9534, due=0.0877, real=9.8657
cdrtool[13292]: Maximum duration for adi@umts.ro to destination 31646 having balance=9.8657 is 3700
cdrtool[13292]: Maximum duration for adi@umts.ro to destination 31800 having balance=9.8657 is 29597
cdrtool[13292]: Maximum duration agregated for adi@umts.ro is (Balance=9.8657)/(Sum of price per second for each destination=0.0030)=3288 s
cdrtool[13292]: CallId=waaivgq89atxmpig6jisphodue0trvf- BillingParty=adi@umts.ro DestId=31800 Balance=9.8657 MaxSessionTime=3288 Spans=2


Pseudo-code for rating engine
-----------------------------

This code is actually implemented in cdrtool.

max_session_time (session, from, to) { 
    list(balance,active_sessions)=get_prepaid_account_from_database();

    if (count(active_sessions[from]) > 0) {
        purge_expired_sessions()

        // simulate call termination for all ongoing calls
        foreach (call in active_sessions[from]) {
            due_balance=used_balance+show_price(call)
        }

        // calculate new virtual balance
        balance_new=balance-due_balance

        // simulate we start parallel calls from scratch at this moment
        // including the new sessionn setup request
        // we skip any connect cost for session already in progress
        active_sessions_new[from]=active_sessions[from]
        active_sessions_new[from][]=session
        foreach (call in active_sessions_new[from]) {
            rate = new Rate(call)
            maxsessiontime=rate->max_session_time()
            // calculate price per second for each session
            price_per_second=price_per_second+balance_new/maxsessiontime
        }

        // return aggregated maxsessiontime
        return balance/price_per_second

    } else {
        // is the first session
        rate = new Rate(session)          
        active_sessions[from][]=session         
        return rate->max_session_time()
    }
}

debit_balance(session, from, to, duration) {
    list(balance,active_sessions)=get_prepaid_account_from_database();
    foreach (call in active_sessions[from]) {
        if (call == session) continue
        new_active_sessions[] = call 
    }  
    // update list of active sessions 
    active_sessions[from]=new_active_sessions
    price=showprice(session,from,to,duration)
    balance=balance-price
    update_prepaid_account_to_database(balance,active_sessions);
}


Pseudo-code for call control engine
-----------------------------------

on_session_setup () {
    max=cdrtool_max_session_time(session, from, to)
    if (sip_connect_call() == true) { 
        // add session to the list of active sessions
        active_sessions[from][]=session
        // set maxsession time for all remaining calls of the same user
        foreach (call in active_sessions[from]) {
            call.maxsessiontime = max
        }
    } 
}

on_session_disconnect () {
   sip_disconnect_call();
   cdrtool_debit_balance(session, from, to, duration)
   // remove session from the list of active sessions
   foreach (call in active_sessions[from]) {
       if (call == session) continue
       new_active_sessions[] = call 
   }  
   // update list of active sessions 
   active_sessions[from]=new_active_sessions
}


Notes
-----

1. The algorithm still suffers from the fact that on disconnect of a call
the user has a bigger balance while the ongoing calls together will not be
able to use it until a new call is setup. One way to improve the algorithm
would be to return a new maxsessiontime with the answer for DebitBalance()
and update the timer of the remaining active sessions accordingly.

2. The rating engine calculates an aggregated common maxsessiontime for all
active calls for a user. This however cannot take in consideration the
duration of the setup time (because is unknown how long it would take) for
the calls that have not yet been established. This can lead to less talk
time for end-user but cannot lead to negative balance.

3. It is not possible to predict when a call will end as it depends on user
choice so when a call spans multiple profiles that have different rates it
is possible that the aggregated prediction will not match. It is unclear if
this can leed to a negative balance. If it does the balance lost by the
operator in the worst case is the tariff diference between profiles for some
sessions in some corner situations.

